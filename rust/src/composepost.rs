//! Logic for post-processing a filesystem tree, server-side.
//!
//! This code runs server side to "postprocess" a filesystem tree (usually
//! containing mostly RPMs) in order to prepare it as an OSTree commit.

// SPDX-License-Identifier: Apache-2.0 OR MIT

use crate::bwrap;
use crate::cxxrsutil::CxxResult;
use anyhow::{anyhow, Context, Result};
use fn_error_context::context;
use nix::sys::stat::Mode;
use openat_ext::OpenatDirExt;
use rayon::prelude::*;
use std::borrow::Cow;
use std::fmt::Write as FmtWrite;
use std::io::{BufRead, BufReader, Seek, Write};
use std::os::unix::fs::PermissionsExt;
use std::os::unix::io::AsRawFd;
use std::path::Path;

use crate::treefile::Treefile;

/* See rpmostree-core.h */
const RPMOSTREE_RPMDB_LOCATION: &str = "usr/share/rpm";
const TRADITIONAL_RPMDB_LOCATION: &str = "var/lib/rpm";

#[context("Moving {}", name)]
fn dir_move_if_exists(src: &openat::Dir, dest: &openat::Dir, name: &str) -> Result<()> {
    if src.exists(name)? {
        openat::rename(src, name, dest, name)?;
    }
    Ok(())
}

/// Initialize an ostree-oriented root filesystem.
///
/// This is hardcoded; in the future we may make more things configurable,
/// but the goal is for all state to be in `/etc` and `/var`.
#[context("Init rootfs")]
fn compose_init_rootfs(rootfs_dfd: &openat::Dir, treefile: &mut Treefile) -> Result<()> {
    use nix::fcntl::OFlag;
    println!("Initializing rootfs");

    let default_dirmode = Mode::from_bits(0o755).unwrap();

    // Unfortunately fchmod() doesn't operate on an O_PATH descriptor
    let flag = OFlag::O_DIRECTORY | OFlag::O_CLOEXEC;
    let nix_rootfs = nix::dir::Dir::openat(rootfs_dfd.as_raw_fd(), ".", flag, default_dirmode)?;

    const TOPLEVEL_DIRS: &[&str] = &["dev", "proc", "run", "sys", "var", "sysroot"];
    const TOPLEVEL_SYMLINKS: &[(&str, &str)] = &[
        ("var/opt", "opt"),
        ("var/srv", "srv"),
        ("var/mnt", "mnt"),
        ("var/roothome", "root"),
        ("var/home", "home"),
        ("run/media", "media"),
        ("sysroot/ostree", "ostree"),
    ];

    nix::sys::stat::fchmod(nix_rootfs.as_raw_fd(), default_dirmode).context("rootfs chown")?;

    TOPLEVEL_DIRS
        .par_iter()
        .try_for_each(|&d| rootfs_dfd.ensure_dir(d, default_dirmode.bits()))?;
    TOPLEVEL_SYMLINKS
        .par_iter()
        .try_for_each(|&(dest, src)| rootfs_dfd.symlink(src, dest))?;

    if treefile.parsed.tmp_is_dir.unwrap_or_default() {
        let tmp_mode = 0o1777;
        rootfs_dfd.ensure_dir("tmp", tmp_mode)?;
        nix::sys::stat::fchmodat(
            Some(nix_rootfs.as_raw_fd()),
            "tmp",
            Mode::from_bits(tmp_mode).unwrap(),
            nix::sys::stat::FchmodatFlags::NoFollowSymlink,
        )?;
    } else {
        rootfs_dfd.symlink("tmp", "sysroot/tmp")?;
    }

    Ok(())
}

/// Prepare rootfs for commit.
///
/// Initialize a basic root filesystem in @target_root_dfd, then walk over the
/// root filesystem in @src_rootfs_fd and take the basic content (/usr, /boot, /var)
/// and cherry pick only specific bits of the rest of the toplevel like compatibility
/// symlinks (e.g. /lib64 -> /usr/lib64) if they exist.
#[context("Preparing rootfs for commit")]
pub fn compose_prepare_rootfs(
    src_rootfs_dfd: i32,
    target_rootfs_dfd: i32,
    treefile: &mut Treefile,
) -> CxxResult<()> {
    let src_rootfs_dfd = &crate::ffiutil::ffi_view_openat_dir(src_rootfs_dfd);
    let target_rootfs_dfd = &crate::ffiutil::ffi_view_openat_dir(target_rootfs_dfd);

    compose_init_rootfs(target_rootfs_dfd, treefile)?;

    println!("Moving /usr to target");
    openat::rename(src_rootfs_dfd, "usr", target_rootfs_dfd, "usr")?;
    /* The kernel may be in the source rootfs /boot; to handle that, we always
     * rename the source /boot to the target, and will handle everything after
     * that in the target root.
     */
    dir_move_if_exists(src_rootfs_dfd, target_rootfs_dfd, "boot")?;

    /* And grab /var - we'll convert to tmpfiles.d later */
    dir_move_if_exists(src_rootfs_dfd, target_rootfs_dfd, "var")?;

    const TOPLEVEL_LINKS: &[&str] = &["lib", "lib64", "lib32", "bin", "sbin"];
    println!("Copying toplevel compat symlinks");
    TOPLEVEL_LINKS
        .par_iter()
        .try_for_each(|&l| dir_move_if_exists(src_rootfs_dfd, target_rootfs_dfd, l))?;

    Ok(())
}

// rpm-ostree uses /home â†’ /var/home by default as generated by our
// rootfs; we don't expect people to change this.  Let's be nice
// and also fixup the $HOME entries generated by `useradd` so
// that `~` shows up as expected in shells, etc.
//
// https://github.com/coreos/fedora-coreos-config/pull/18
// https://pagure.io/workstation-ostree-config/pull-request/121
// https://discussion.fedoraproject.org/t/adapting-user-home-in-etc-passwd/487/6
// https://github.com/justjanne/powerline-go/issues/94
fn postprocess_useradd(rootfs_dfd: &openat::Dir) -> Result<()> {
    let path = Path::new("usr/etc/default/useradd");
    if let Some(f) = rootfs_dfd.open_file_optional(path)? {
        rootfs_dfd.write_file_with(&path, 0o644, |bufw| -> Result<_> {
            let f = BufReader::new(&f);
            for line in f.lines() {
                let line = line?;
                if !line.starts_with("HOME=") {
                    bufw.write_all(line.as_bytes())?;
                } else {
                    bufw.write_all(b"HOME=/var/home")?;
                }
                bufw.write_all(b"\n")?;
            }
            Ok(())
        })?;
    }
    Ok(())
}

// We keep hitting issues with the ostree-remount preset not being
// enabled; let's just do this rather than trying to propagate the
// preset everywhere.
fn postprocess_presets(rootfs_dfd: &openat::Dir) -> Result<()> {
    let wantsdir = "usr/lib/systemd/system/multi-user.target.wants";
    rootfs_dfd.ensure_dir_all(wantsdir, 0o755)?;
    for service in &["ostree-remount.service", "ostree-finalize-staged.path"] {
        let target = format!("../{}", service);
        let loc = Path::new(wantsdir).join(service);
        rootfs_dfd.symlink(&loc, target)?;
    }
    Ok(())
}

// We keep hitting issues with the ostree-remount preset not being
// enabled; let's just do this rather than trying to propagate the
// preset everywhere.
fn postprocess_rpm_macro(rootfs_dfd: &openat::Dir) -> Result<()> {
    let rpm_macros_dir = "usr/lib/rpm/macros.d";
    rootfs_dfd.ensure_dir_all(rpm_macros_dir, 0o755)?;
    let rpm_macros_dfd = rootfs_dfd.sub_dir(rpm_macros_dir)?;
    rpm_macros_dfd.write_file_with("macros.rpm-ostree", 0o644, |w| -> Result<()> {
        w.write_all(b"%_dbpath /")?;
        w.write_all(RPMOSTREE_RPMDB_LOCATION.as_bytes())?;
        Ok(())
    })?;
    Ok(())
}

// This function does two things: (1) make sure there is a /home --> /var/home substitution rule,
// and (2) make sure there *isn't* a /var/home -> /home substition rule. The latter check won't
// technically be needed once downstreams have:
// https://src.fedoraproject.org/rpms/selinux-policy/pull-request/14
fn postprocess_subs_dist(rootfs_dfd: &openat::Dir) -> Result<()> {
    let path = Path::new("usr/etc/selinux/targeted/contexts/files/file_contexts.subs_dist");
    if let Some(f) = rootfs_dfd.open_file_optional(path)? {
        rootfs_dfd.write_file_with(&path, 0o644, |w| -> Result<()> {
            let f = BufReader::new(&f);
            for line in f.lines() {
                let line = line?;
                if line.starts_with("/var/home ") {
                    w.write_all(b"# https://github.com/projectatomic/rpm-ostree/pull/1754\n")?;
                    w.write_all(b"# ")?;
                }
                w.write_all(line.as_bytes())?;
                w.write_all(b"\n")?;
            }
            w.write_all(b"# https://github.com/projectatomic/rpm-ostree/pull/1754\n")?;
            w.write_all(b"/home /var/home")?;
            w.write_all(b"\n")?;
            Ok(())
        })?;
    }
    Ok(())
}

/// Final processing steps.
///
/// This function is called from rpmostree_postprocess_final(); think of
/// it as the bits of that function that we've chosen to implement in Rust.
/// It takes care of all things that are really required to use rpm-ostree
/// on the target host.
pub fn compose_postprocess_final(rootfs_dfd: i32) -> CxxResult<()> {
    let rootfs_dfd = crate::ffiutil::ffi_view_openat_dir(rootfs_dfd);
    let tasks = [
        postprocess_useradd,
        postprocess_presets,
        postprocess_subs_dist,
        postprocess_rpm_macro,
    ];
    Ok(tasks.par_iter().try_for_each(|f| f(&rootfs_dfd))?)
}

#[context("Handling treefile 'units'")]
fn compose_postprocess_units(rootfs_dfd: &openat::Dir, treefile: &mut Treefile) -> Result<()> {
    let units = if let Some(u) = treefile.parsed.units.as_ref() {
        u
    } else {
        return Ok(());
    };
    let multiuser_wants = Path::new("usr/etc/systemd/system/multi-user.target.wants");
    // Sanity check
    if !rootfs_dfd.exists("usr/etc")? {
        return Err(anyhow!("Missing usr/etc in rootfs"));
    }
    rootfs_dfd.ensure_dir_all(multiuser_wants, 0o755)?;

    for unit in units {
        let dest = multiuser_wants.join(unit);
        if rootfs_dfd.exists(&dest)? {
            continue;
        }

        println!("Adding {} to multi-user.target.wants", unit);
        let target = format!("/usr/lib/systemd/system/{}", unit);
        rootfs_dfd.symlink(&dest, &target)?;
    }
    Ok(())
}

#[context("Handling treefile 'default-target'")]
fn compose_postprocess_default_target(rootfs_dfd: &openat::Dir, target: &str) -> Result<()> {
    /* This used to be in /etc, but doing it in /usr makes more sense, as it's
     * part of the OS defaults. This was changed in particular to work with
     * ConditionFirstBoot= which runs `systemctl preset-all`:
     * https://github.com/projectatomic/rpm-ostree/pull/1425
     */
    let default_target_path = "usr/lib/systemd/system/default.target";
    rootfs_dfd.remove_file_optional(default_target_path)?;
    let dest = format!("/usr/lib/systemd/system/{}", target);
    rootfs_dfd.symlink(default_target_path, dest)?;

    Ok(())
}

/// The treefile format has two kinds of postprocessing scripts;
/// there's a single `postprocess-script` as well as inline (anonymous)
/// scripts.  This function executes both kinds in bwrap containers.
fn compose_postprocess_scripts(
    rootfs_dfd: &openat::Dir,
    treefile: &mut Treefile,
    unified_core: bool,
) -> Result<()> {
    // Execute the anonymous (inline) scripts.
    for (i, script) in treefile.parsed.postprocess.iter().flatten().enumerate() {
        let binpath = format!("/usr/bin/rpmostree-postprocess-inline-{}", i);
        let target_binpath = &binpath[1..];

        rootfs_dfd.write_file_contents(target_binpath, 0o755, script)?;
        println!("Executing `postprocess` inline script '{}'", i);
        let child_argv = vec![binpath.to_string()];
        let _ =
            bwrap::bubblewrap_run_sync(rootfs_dfd.as_raw_fd(), &child_argv, false, unified_core)?;
        rootfs_dfd.remove_file(target_binpath)?;
    }

    // And the single postprocess script.
    if let Some(postprocess_script) = treefile.get_postprocess_script() {
        let binpath = "/usr/bin/rpmostree-treefile-postprocess-script";
        let target_binpath = &binpath[1..];
        postprocess_script.seek(std::io::SeekFrom::Start(0))?;
        let mut reader = std::io::BufReader::new(postprocess_script);
        rootfs_dfd.write_file_with(target_binpath, 0o755, |w| std::io::copy(&mut reader, w))?;
        println!("Executing postprocessing script");

        let child_argv = &vec![binpath.to_string()];
        let _ = crate::bwrap::bubblewrap_run_sync(
            rootfs_dfd.as_raw_fd(),
            child_argv,
            false,
            unified_core,
        )
        .context("Executing postprocessing script")?;

        rootfs_dfd.remove_file(target_binpath)?;
        println!("Finished postprocessing script");
    }
    Ok(())
}

/// Logic for handling treefile `remove-files`.
#[context("Handling `remove-files`")]
pub fn compose_postprocess_remove_files(
    rootfs_dfd: &openat::Dir,
    treefile: &mut Treefile,
) -> CxxResult<()> {
    for name in treefile.parsed.remove_files.iter().flatten() {
        let p = Path::new(name);
        if p.is_absolute() {
            return Err(anyhow!("Invalid absolute path: {}", name).into());
        }
        if name.contains("..") {
            return Err(anyhow!("Invalid '..' in path: {}", name).into());
        }
        println!("Deleting: {}", name);
        rootfs_dfd.remove_all(name)?;
    }
    Ok(())
}

fn compose_postprocess_add_files(rootfs_dfd: &openat::Dir, treefile: &mut Treefile) -> Result<()> {
    // Make a deep copy here because get_add_file_fd() also wants an &mut
    // reference.
    let add_files: Vec<_> = treefile
        .parsed
        .add_files
        .iter()
        .flatten()
        .cloned()
        .collect();
    for (src, dest) in add_files {
        let reldest = dest.trim_start_matches('/');
        if reldest.is_empty() {
            return Err(anyhow!("Invalid add-files destination: {}", dest).into());
        }
        let dest = if reldest.starts_with("etc/") {
            Cow::Owned(format!("usr/{}", reldest))
        } else {
            Cow::Borrowed(reldest)
        };

        println!("Adding file {}", dest);
        let dest = Path::new(&*dest);
        if let Some(parent) = dest.parent() {
            rootfs_dfd.ensure_dir_all(parent, 0o755)?;
        }

        let fd = treefile.get_add_file(&src);
        fd.seek(std::io::SeekFrom::Start(0))?;
        let mut reader = std::io::BufReader::new(fd);
        let mode = reader.get_mut().metadata()?.permissions().mode();
        rootfs_dfd.write_file_with(dest, mode, |w| std::io::copy(&mut reader, w))?;
    }
    Ok(())
}

#[context("Symlinking {}", TRADITIONAL_RPMDB_LOCATION)]
fn compose_postprocess_rpmdb(rootfs_dfd: &openat::Dir) -> Result<()> {
    /* This works around a potential issue with libsolv if we go down the
     * rpmostree_get_pkglist_for_root() path. Though rpm has been using the
     * /usr/share/rpm location (since the RpmOstreeContext set the _dbpath macro),
     * the /var/lib/rpm directory will still exist, but be empty. libsolv gets
     * confused because it sees the /var/lib/rpm dir and doesn't even try the
     * /usr/share/rpm location, and eventually dies when it tries to load the
     * data. XXX: should probably send a patch upstream to libsolv.
     *
     * So we set the symlink now. This is also what we do on boot anyway for
     * compatibility reasons using tmpfiles.
     * */
    rootfs_dfd.remove_all(TRADITIONAL_RPMDB_LOCATION)?;
    rootfs_dfd.symlink(
        TRADITIONAL_RPMDB_LOCATION,
        format!("../../{}", RPMOSTREE_RPMDB_LOCATION),
    )?;
    Ok(())
}

/// Rust portion of rpmostree_treefile_postprocessing()
pub fn compose_postprocess(
    rootfs_dfd: i32,
    treefile: &mut Treefile,
    next_version: &str,
    unified_core: bool,
) -> CxxResult<()> {
    let rootfs_dfd = &crate::ffiutil::ffi_view_openat_dir(rootfs_dfd);

    // One of several dances we do around this that really needs to be completely
    // reworked.
    if rootfs_dfd.exists("etc")? {
        rootfs_dfd.local_rename("etc", "usr/etc")?;
    }

    compose_postprocess_rpmdb(rootfs_dfd)?;
    compose_postprocess_units(&rootfs_dfd, treefile)?;
    if let Some(t) = treefile.parsed.default_target.as_deref() {
        compose_postprocess_default_target(&rootfs_dfd, t)?;
    }

    compose_postprocess_mutate_os_release(rootfs_dfd, treefile, next_version)?;
    treefile.write_compose_json(rootfs_dfd)?;

    let etc_guard = crate::core::prepare_tempetc_guard(rootfs_dfd.as_raw_fd())?;
    // These ones depend on the /etc path
    compose_postprocess_remove_files(rootfs_dfd, treefile)?;
    compose_postprocess_add_files(rootfs_dfd, treefile)?;
    etc_guard.undo()?;

    compose_postprocess_scripts(rootfs_dfd, treefile, unified_core)?;

    Ok(())
}

/// Implementation of the treefile `mutate-os-release` field.
#[context("Updating os-release with commit version")]
fn compose_postprocess_mutate_os_release(
    rootfs_dfd: &openat::Dir,
    treefile: &mut Treefile,
    next_version: &str,
) -> Result<()> {
    let base_version = if let Some(base_version) = treefile.parsed.mutate_os_release.as_deref() {
        base_version
    } else {
        return Ok(());
    };
    if next_version.is_empty() {
        println!("Ignoring mutate-os-release: no commit version specified.");
        return Ok(());
    }
    // find the real path to os-release using bwrap; this is an overkill but safer way
    // of resolving a symlink relative to a rootfs (see discussions in
    // https://github.com/projectatomic/rpm-ostree/pull/410/)
    let argv = &vec!["realpath".to_string(), "/etc/os-release".to_string()];
    let path = crate::bwrap::bubblewrap_run_sync(rootfs_dfd.as_raw_fd(), argv, true, true)
        .context("Running realpath")?;
    let path = String::from_utf8(path).context("Parsing realpath")?;
    let path = path.trim_start_matches("/").trim_end();
    let path = if path.is_empty() {
        // fallback on just overwriting etc/os-release
        "etc/os-release"
    } else {
        path
    };
    println!("Updating {}", path);
    let contents = rootfs_dfd
        .read_to_string(path)
        .with_context(|| format!("Reading {}", path))?;
    let new_contents = mutate_os_release_contents(&contents, base_version, next_version);
    rootfs_dfd
        .write_file_contents(path, 0o644, new_contents.as_bytes())
        .with_context(|| format!("Writing {}", path))?;
    Ok(())
}

/// Given the contents of a /usr/lib/os-release file,
/// update the `VERSION` and `PRETTY_NAME` fields.
fn mutate_os_release_contents(contents: &str, base_version: &str, next_version: &str) -> String {
    let mut buf = String::new();
    for line in contents.lines() {
        if line.is_empty() {
            continue;
        }
        let prefixes = &["VERSION=", "PRETTY_NAME="];
        if let Some((prefix, rest)) = strip_any_prefix(line, prefixes) {
            buf.push_str(prefix);
            let replaced = rest.replace(base_version, next_version);
            buf.push_str(&replaced);
        } else {
            buf.push_str(line);
        }
        buf.push('\n');
    }

    // Unwrap safety; we provided it UTF-8
    let quoted_version = glib::shell_quote(next_version).unwrap();
    let quoted_version = quoted_version.to_str().unwrap();
    // Unwrap safety: write! to a String can't fail
    writeln!(buf, "OSTREE_VERSION={}", quoted_version).unwrap();

    buf
}

/// Given a string and a set of possible prefixes, return the split
/// prefix and remaining string, or `None` if no matches.
fn strip_any_prefix<'a, 'b>(s: &'a str, prefixes: &[&'b str]) -> Option<(&'b str, &'a str)> {
    prefixes
        .iter()
        .find_map(|&p| s.strip_prefix(p).map(|r| (p, r)))
}

/// Inject `altfiles` after `files` for `passwd:` and `group:` entries.
fn add_altfiles(buf: &str) -> Result<String> {
    let mut r = String::with_capacity(buf.len());
    for line in buf.lines() {
        let parts = if let Some(p) = strip_any_prefix(line, &["passwd:", "group:"]) {
            p
        } else {
            r.push_str(line);
            r.push('\n');
            continue;
        };
        let (prefix, rest) = parts;
        r.push_str(prefix);

        let mut inserted = false;
        for elt in rest.split_whitespace() {
            // Already have altfiles?  We're done
            if elt == "altfiles" {
                return Ok(buf.to_string());
            }
            // We prefer `files altfiles`
            if !inserted && elt == "files" {
                r.push_str(" files altfiles");
                inserted = true;
            } else {
                r.push(' ');
                r.push_str(elt);
            }
        }
        if !inserted {
            r.push_str(" altfiles");
        }
        r.push('\n');
    }
    Ok(r)
}

/// Add `altfiles` entries to `nsswitch.conf`.
///
/// rpm-ostree currently depends on `altfiles`
#[context("Adding altfiles to /etc/nsswitch.conf")]
pub fn composepost_nsswitch_altfiles(rootfs_dfd: i32) -> CxxResult<()> {
    let rootfs_dfd = &crate::ffiutil::ffi_view_openat_dir(rootfs_dfd);
    let path = "usr/etc/nsswitch.conf";
    let nsswitch = rootfs_dfd.read_to_string(path)?;
    let nsswitch = add_altfiles(&nsswitch)?;
    rootfs_dfd.write_file_contents(path, 0o644, nsswitch.as_bytes())?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::treefile::tests as tf_tests;

    #[test]
    fn stripany() {
        let s = "foo: bar";
        assert!(strip_any_prefix(s, &[]).is_none());
        assert_eq!(
            strip_any_prefix(s, &["baz:", "foo:", "bar:"]).unwrap(),
            ("foo:", " bar")
        );
    }

    #[test]
    fn altfiles_replaced() {
        let orig = r##"# blah blah nss stuff
# more blah blah

# passwd: db files
# shadow: db files
# shadow: db files

passwd:     sss files systemd
shadow:     files
group:      sss files systemd
hosts:      files resolve [!UNAVAIL=return] myhostname dns
automount:  files sss
"##;
        let expected = r##"# blah blah nss stuff
# more blah blah

# passwd: db files
# shadow: db files
# shadow: db files

passwd: sss files altfiles systemd
shadow:     files
group: sss files altfiles systemd
hosts:      files resolve [!UNAVAIL=return] myhostname dns
automount:  files sss
"##;
        let replaced = add_altfiles(orig).unwrap();
        assert_eq!(replaced.as_str(), expected);
        let replaced2 = add_altfiles(replaced.as_str()).unwrap();
        assert_eq!(replaced2.as_str(), expected);
    }

    #[test]
    fn test_mutate_os_release() {
        let orig = r##"NAME=Fedora
VERSION="33 (Container Image)"
ID=fedora
VERSION_ID=33
VERSION_CODENAME=""
PRETTY_NAME="Fedora 33 (Container Image)"
CPE_NAME="cpe:/o:fedoraproject:fedora:33"
"##;
        let expected = r##"NAME=Fedora
VERSION="33.4 (Container Image)"
ID=fedora
VERSION_ID=33
VERSION_CODENAME=""
PRETTY_NAME="Fedora 33.4 (Container Image)"
CPE_NAME="cpe:/o:fedoraproject:fedora:33"
OSTREE_VERSION='33.4'
"##;
        let replaced = mutate_os_release_contents(orig, "33", "33.4");
        assert_eq!(replaced.as_str(), expected);
    }

    #[test]
    fn test_init_rootfs() -> Result<()> {
        let t = tempfile::tempdir()?;
        let d = &openat::Dir::open(t.path())?;
        let mut tf = tf_tests::new_test_treefile(
            t.path(),
            tf_tests::VALID_PRELUDE,
            Some(tf_tests::ARCH_X86_64),
        )?;
        compose_init_rootfs(d, &mut tf)?;

        Ok(())
    }
}
